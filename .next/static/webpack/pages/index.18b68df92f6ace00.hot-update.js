"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/SplashCursor.tsx":
/*!*************************************!*\
  !*** ./components/SplashCursor.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SplashCursor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction pointerPrototype() {\n    return {\n        id: -1,\n        texcoordX: 0,\n        texcoordY: 0,\n        prevTexcoordX: 0,\n        prevTexcoordY: 0,\n        deltaX: 0,\n        deltaY: 0,\n        down: false,\n        moved: false,\n        color: {\n            r: 0,\n            g: 0,\n            b: 0\n        }\n    };\n}\nfunction SplashCursor(param) {\n    let { SIM_RESOLUTION = 128, DYE_RESOLUTION = 1440, CAPTURE_RESOLUTION = 512, DENSITY_DISSIPATION = 3.5, VELOCITY_DISSIPATION = 2, PRESSURE = 0.1, PRESSURE_ITERATIONS = 20, CURL = 3, SPLAT_RADIUS = 0.2, SPLAT_FORCE = 6000, SHADING = true, COLOR_UPDATE_SPEED = 10, BACK_COLOR = {\n        r: 0.5,\n        g: 0,\n        b: 0\n    }, TRANSPARENT = true } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        let pointers = [\n            pointerPrototype()\n        ];\n        let config = {\n            SIM_RESOLUTION: SIM_RESOLUTION,\n            DYE_RESOLUTION: DYE_RESOLUTION,\n            CAPTURE_RESOLUTION: CAPTURE_RESOLUTION,\n            DENSITY_DISSIPATION: DENSITY_DISSIPATION,\n            VELOCITY_DISSIPATION: VELOCITY_DISSIPATION,\n            PRESSURE: PRESSURE,\n            PRESSURE_ITERATIONS: PRESSURE_ITERATIONS,\n            CURL: CURL,\n            SPLAT_RADIUS: SPLAT_RADIUS,\n            SPLAT_FORCE: SPLAT_FORCE,\n            SHADING,\n            COLOR_UPDATE_SPEED: COLOR_UPDATE_SPEED,\n            PAUSED: false,\n            BACK_COLOR,\n            TRANSPARENT\n        };\n        const { gl, ext } = getWebGLContext(canvas);\n        if (!gl || !ext) return;\n        if (!ext.supportLinearFiltering) {\n            config.DYE_RESOLUTION = 256;\n            config.SHADING = false;\n        }\n        function getWebGLContext(canvas) {\n            const params = {\n                alpha: true,\n                depth: false,\n                stencil: false,\n                antialias: false,\n                preserveDrawingBuffer: false\n            };\n            let gl = canvas.getContext(\"webgl2\", params);\n            if (!gl) {\n                gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n            }\n            if (!gl) {\n                throw new Error(\"Unable to initialize WebGL.\");\n            }\n            const isWebGL2 = \"drawBuffers\" in gl;\n            let supportLinearFiltering = false;\n            let halfFloat = null;\n            if (isWebGL2) {\n                gl.getExtension(\"EXT_color_buffer_float\");\n                supportLinearFiltering = !!gl.getExtension(\"OES_texture_float_linear\");\n            } else {\n                halfFloat = gl.getExtension(\"OES_texture_half_float\");\n                supportLinearFiltering = !!gl.getExtension(\"OES_texture_half_float_linear\");\n            }\n            gl.clearColor(0, 0, 0, 1);\n            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES || 0;\n            let formatRGBA;\n            let formatRG;\n            let formatR;\n            if (isWebGL2) {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n            } else {\n                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n            }\n            return {\n                gl,\n                ext: {\n                    formatRGBA,\n                    formatRG,\n                    formatR,\n                    halfFloatTexType,\n                    supportLinearFiltering\n                }\n            };\n        }\n        function getSupportedFormat(gl, internalFormat, format, type) {\n            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n                if (\"drawBuffers\" in gl) {\n                    const gl2 = gl;\n                    switch(internalFormat){\n                        case gl2.R16F:\n                            return getSupportedFormat(gl2, gl2.RG16F, gl2.RG, type);\n                        case gl2.RG16F:\n                            return getSupportedFormat(gl2, gl2.RGBA16F, gl2.RGBA, type);\n                        default:\n                            return null;\n                    }\n                }\n                return null;\n            }\n            return {\n                internalFormat,\n                format\n            };\n        }\n        function supportRenderTextureFormat(gl, internalFormat, format, type) {\n            const texture = gl.createTexture();\n            if (!texture) return false;\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            if (!fbo) return false;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            return status === gl.FRAMEBUFFER_COMPLETE;\n        }\n        function hashCode(s) {\n            if (!s.length) return 0;\n            let hash = 0;\n            for(let i = 0; i < s.length; i++){\n                hash = (hash << 5) - hash + s.charCodeAt(i);\n                hash |= 0;\n            }\n            return hash;\n        }\n        function addKeywords(source, keywords) {\n            if (!keywords) return source;\n            let keywordsString = \"\";\n            for (const keyword of keywords){\n                keywordsString += \"#define \".concat(keyword, \"\\n\");\n            }\n            return keywordsString + source;\n        }\n        function compileShader(type, source) {\n            let keywords = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n            const shaderSource = addKeywords(source, keywords);\n            const shader = gl.createShader(type);\n            if (!shader) return null;\n            gl.shaderSource(shader, shaderSource);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.trace(gl.getShaderInfoLog(shader));\n            }\n            return shader;\n        }\n        function createProgram(vertexShader, fragmentShader) {\n            if (!vertexShader || !fragmentShader) return null;\n            const program = gl.createProgram();\n            if (!program) return null;\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                console.trace(gl.getProgramInfoLog(program));\n            }\n            return program;\n        }\n        function getUniforms(program) {\n            let uniforms = {};\n            const uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for(let i = 0; i < uniformCount; i++){\n                const uniformInfo = gl.getActiveUniform(program, i);\n                if (uniformInfo) {\n                    uniforms[uniformInfo.name] = gl.getUniformLocation(program, uniformInfo.name);\n                }\n            }\n            return uniforms;\n        }\n        class Program {\n            bind() {\n                if (this.program) gl.useProgram(this.program);\n            }\n            constructor(vertexShader, fragmentShader){\n                this.program = createProgram(vertexShader, fragmentShader);\n                this.uniforms = this.program ? getUniforms(this.program) : {};\n            }\n        }\n        class Material {\n            setKeywords(keywords) {\n                let hash = 0;\n                for (const kw of keywords){\n                    hash += hashCode(kw);\n                }\n                let program = this.programs[hash];\n                if (program == null) {\n                    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n                    program = createProgram(this.vertexShader, fragmentShader);\n                    this.programs[hash] = program;\n                }\n                if (program === this.activeProgram) return;\n                if (program) {\n                    this.uniforms = getUniforms(program);\n                }\n                this.activeProgram = program;\n            }\n            bind() {\n                if (this.activeProgram) {\n                    gl.useProgram(this.activeProgram);\n                }\n            }\n            constructor(vertexShader, fragmentShaderSource){\n                this.vertexShader = vertexShader;\n                this.fragmentShaderSource = fragmentShaderSource;\n                this.programs = {};\n                this.activeProgram = null;\n                this.uniforms = {};\n            }\n        }\n        const baseVertexShader = compileShader(gl.VERTEX_SHADER, \"\\n      precision highp float;\\n      attribute vec2 aPosition;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform vec2 texelSize;\\n\\n      void main () {\\n        vUv = aPosition * 0.5 + 0.5;\\n        vL = vUv - vec2(texelSize.x, 0.0);\\n        vR = vUv + vec2(texelSize.x, 0.0);\\n        vT = vUv + vec2(0.0, texelSize.y);\\n        vB = vUv - vec2(0.0, texelSize.y);\\n        gl_Position = vec4(aPosition, 0.0, 1.0);\\n      }\\n    \");\n        const copyShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      uniform sampler2D uTexture;\\n\\n      void main () {\\n          gl_FragColor = texture2D(uTexture, vUv);\\n      }\\n    \");\n        const clearShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      uniform sampler2D uTexture;\\n      uniform float value;\\n\\n      void main () {\\n          gl_FragColor = value * texture2D(uTexture, vUv);\\n      }\\n    \");\n        const displayShaderSource = \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uTexture;\\n      uniform sampler2D uDithering;\\n      uniform vec2 ditherScale;\\n      uniform vec2 texelSize;\\n\\n      vec3 linearToGamma (vec3 color) {\\n          color = max(color, vec3(0));\\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\\n      }\\n\\n      void main () {\\n          vec3 c = texture2D(uTexture, vUv).rgb;\\n          #ifdef SHADING\\n              vec3 lc = texture2D(uTexture, vL).rgb;\\n              vec3 rc = texture2D(uTexture, vR).rgb;\\n              vec3 tc = texture2D(uTexture, vT).rgb;\\n              vec3 bc = texture2D(uTexture, vB).rgb;\\n\\n              float dx = length(rc) - length(lc);\\n              float dy = length(tc) - length(bc);\\n\\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\\n              vec3 l = vec3(0.0, 0.0, 1.0);\\n\\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\\n              c *= diffuse;\\n          #endif\\n\\n          float a = max(c.r, max(c.g, c.b));\\n          gl_FragColor = vec4(c, a);\\n      }\\n    \";\n        const splatShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      uniform sampler2D uTarget;\\n      uniform float aspectRatio;\\n      uniform vec3 color;\\n      uniform vec2 point;\\n      uniform float radius;\\n\\n      void main () {\\n          vec2 p = vUv - point.xy;\\n          p.x *= aspectRatio;\\n          vec3 splat = exp(-dot(p, p) / radius) * color;\\n          vec3 base = texture2D(uTarget, vUv).xyz;\\n          gl_FragColor = vec4(base + splat, 1.0);\\n      }\\n    \");\n        const advectionShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      uniform sampler2D uVelocity;\\n      uniform sampler2D uSource;\\n      uniform vec2 texelSize;\\n      uniform vec2 dyeTexelSize;\\n      uniform float dt;\\n      uniform float dissipation;\\n\\n      vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\\n          vec2 st = uv / tsize - 0.5;\\n          vec2 iuv = floor(st);\\n          vec2 fuv = fract(st);\\n\\n          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\\n          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\\n          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\\n          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\\n\\n          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\\n      }\\n\\n      void main () {\\n          #ifdef MANUAL_FILTERING\\n              vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\\n              vec4 result = bilerp(uSource, coord, dyeTexelSize);\\n          #else\\n              vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\\n              vec4 result = texture2D(uSource, coord);\\n          #endif\\n          float decay = 1.0 + dissipation * dt;\\n          gl_FragColor = result / decay;\\n      }\\n    \", ext.supportLinearFiltering ? null : [\n            \"MANUAL_FILTERING\"\n        ]);\n        const divergenceShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uVelocity, vL).x;\\n          float R = texture2D(uVelocity, vR).x;\\n          float T = texture2D(uVelocity, vT).y;\\n          float B = texture2D(uVelocity, vB).y;\\n\\n          vec2 C = texture2D(uVelocity, vUv).xy;\\n          if (vL.x < 0.0) { L = -C.x; }\\n          if (vR.x > 1.0) { R = -C.x; }\\n          if (vT.y > 1.0) { T = -C.y; }\\n          if (vB.y < 0.0) { B = -C.y; }\\n\\n          float div = 0.5 * (R - L + T - B);\\n          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const curlShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uVelocity, vL).y;\\n          float R = texture2D(uVelocity, vR).y;\\n          float T = texture2D(uVelocity, vT).x;\\n          float B = texture2D(uVelocity, vB).x;\\n          float vorticity = R - L - T + B;\\n          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const vorticityShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision highp float;\\n      precision highp sampler2D;\\n      varying vec2 vUv;\\n      varying vec2 vL;\\n      varying vec2 vR;\\n      varying vec2 vT;\\n      varying vec2 vB;\\n      uniform sampler2D uVelocity;\\n      uniform sampler2D uCurl;\\n      uniform float curl;\\n      uniform float dt;\\n\\n      void main () {\\n          float L = texture2D(uCurl, vL).x;\\n          float R = texture2D(uCurl, vR).x;\\n          float T = texture2D(uCurl, vT).x;\\n          float B = texture2D(uCurl, vB).x;\\n          float C = texture2D(uCurl, vUv).x;\\n\\n          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\\n          force /= length(force) + 0.0001;\\n          force *= curl * C;\\n          force.y *= -1.0;\\n\\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\\n          velocity += force * dt;\\n          velocity = min(max(velocity, -1000.0), 1000.0);\\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\\n      }\\n    \");\n        const pressureShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uPressure;\\n      uniform sampler2D uDivergence;\\n\\n      void main () {\\n          float L = texture2D(uPressure, vL).x;\\n          float R = texture2D(uPressure, vR).x;\\n          float T = texture2D(uPressure, vT).x;\\n          float B = texture2D(uPressure, vB).x;\\n          float C = texture2D(uPressure, vUv).x;\\n          float divergence = texture2D(uDivergence, vUv).x;\\n          float pressure = (L + R + B + T - divergence) * 0.25;\\n          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\\n      }\\n    \");\n        const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, \"\\n      precision mediump float;\\n      precision mediump sampler2D;\\n      varying highp vec2 vUv;\\n      varying highp vec2 vL;\\n      varying highp vec2 vR;\\n      varying highp vec2 vT;\\n      varying highp vec2 vB;\\n      uniform sampler2D uPressure;\\n      uniform sampler2D uVelocity;\\n\\n      void main () {\\n          float L = texture2D(uPressure, vL).x;\\n          float R = texture2D(uPressure, vR).x;\\n          float T = texture2D(uPressure, vT).x;\\n          float B = texture2D(uPressure, vB).x;\\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\\n          velocity.xy -= vec2(R - L, T - B);\\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\\n      }\\n    \");\n        const blit = (()=>{\n            const buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n                -1,\n                -1,\n                -1,\n                1,\n                1,\n                1,\n                1,\n                -1\n            ]), gl.STATIC_DRAW);\n            const elemBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elemBuffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([\n                0,\n                1,\n                2,\n                0,\n                2,\n                3\n            ]), gl.STATIC_DRAW);\n            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(0);\n            return function(target) {\n                let doClear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                if (!gl) return;\n                if (!target) {\n                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                } else {\n                    gl.viewport(0, 0, target.width, target.height);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n                }\n                if (doClear) {\n                    gl.clearColor(0, 0, 0, 1);\n                    gl.clear(gl.COLOR_BUFFER_BIT);\n                }\n                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            };\n        })();\n        let dye;\n        let velocity;\n        let divergence;\n        let curl;\n        let pressure;\n        const copyProgram = new Program(baseVertexShader, copyShader);\n        const clearProgram = new Program(baseVertexShader, clearShader);\n        const splatProgram = new Program(baseVertexShader, splatShader);\n        const advectionProgram = new Program(baseVertexShader, advectionShader);\n        const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n        const curlProgram = new Program(baseVertexShader, curlShader);\n        const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n        const pressureProgram = new Program(baseVertexShader, pressureShader);\n        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n        const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n        function createFBO(w, h, internalFormat, format, type, param) {\n            gl.activeTexture(gl.TEXTURE0);\n            const texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n            const fbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            gl.viewport(0, 0, w, h);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            const texelSizeX = 1 / w;\n            const texelSizeY = 1 / h;\n            return {\n                texture,\n                fbo,\n                width: w,\n                height: h,\n                texelSizeX,\n                texelSizeY,\n                attach (id) {\n                    gl.activeTexture(gl.TEXTURE0 + id);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    return id;\n                }\n            };\n        }\n        function createDoubleFBO(w, h, internalFormat, format, type, param) {\n            const fbo1 = createFBO(w, h, internalFormat, format, type, param);\n            const fbo2 = createFBO(w, h, internalFormat, format, type, param);\n            return {\n                width: w,\n                height: h,\n                texelSizeX: fbo1.texelSizeX,\n                texelSizeY: fbo1.texelSizeY,\n                read: fbo1,\n                write: fbo2,\n                swap () {\n                    const tmp = this.read;\n                    this.read = this.write;\n                    this.write = tmp;\n                }\n            };\n        }\n        function resizeFBO(target, w, h, internalFormat, format, type, param) {\n            const newFBO = createFBO(w, h, internalFormat, format, type, param);\n            copyProgram.bind();\n            if (copyProgram.uniforms.uTexture) gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n            blit(newFBO, false);\n            return newFBO;\n        }\n        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n            if (target.width === w && target.height === h) return target;\n            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n            target.write = createFBO(w, h, internalFormat, format, type, param);\n            target.width = w;\n            target.height = h;\n            target.texelSizeX = 1 / w;\n            target.texelSizeY = 1 / h;\n            return target;\n        }\n        function initFramebuffers() {\n            const simRes = getResolution(config.SIM_RESOLUTION);\n            const dyeRes = getResolution(config.DYE_RESOLUTION);\n            const texType = ext.halfFloatTexType;\n            const rgba = ext.formatRGBA;\n            const rg = ext.formatRG;\n            const r = ext.formatR;\n            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n            gl.disable(gl.BLEND);\n            if (!dye) {\n                dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            } else {\n                dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n            }\n            if (!velocity) {\n                velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            } else {\n                velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n            }\n            divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n            pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n        }\n        function updateKeywords() {\n            const displayKeywords = [];\n            if (config.SHADING) displayKeywords.push(\"SHADING\");\n            displayMaterial.setKeywords(displayKeywords);\n        }\n        function getResolution(resolution) {\n            const w = gl.drawingBufferWidth;\n            const h = gl.drawingBufferHeight;\n            const aspectRatio = w / h;\n            let aspect = aspectRatio < 1 ? 1 / aspectRatio : aspectRatio;\n            const min = Math.round(resolution);\n            const max = Math.round(resolution * aspect);\n            if (w > h) {\n                return {\n                    width: max,\n                    height: min\n                };\n            }\n            return {\n                width: min,\n                height: max\n            };\n        }\n        function scaleByPixelRatio(input) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            return Math.floor(input * pixelRatio);\n        }\n        updateKeywords();\n        initFramebuffers();\n        let lastUpdateTime = Date.now();\n        let colorUpdateTimer = 0.0;\n        function updateFrame() {\n            const dt = calcDeltaTime();\n            if (resizeCanvas()) initFramebuffers();\n            updateColors(dt);\n            applyInputs();\n            step(dt);\n            render(null);\n            requestAnimationFrame(updateFrame);\n        }\n        function calcDeltaTime() {\n            const now = Date.now();\n            let dt = (now - lastUpdateTime) / 1000;\n            dt = Math.min(dt, 0.016666);\n            lastUpdateTime = now;\n            return dt;\n        }\n        function resizeCanvas() {\n            const width = scaleByPixelRatio(canvas.clientWidth);\n            const height = scaleByPixelRatio(canvas.clientHeight);\n            if (canvas.width !== width || canvas.height !== height) {\n                canvas.width = width;\n                canvas.height = height;\n                return true;\n            }\n            return false;\n        }\n        function updateColors(dt) {\n            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n            if (colorUpdateTimer >= 1) {\n                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n                pointers.forEach((p)=>{\n                    p.color = generateColor();\n                });\n            }\n        }\n        function applyInputs() {\n            for (const p of pointers){\n                if (p.moved) {\n                    p.moved = false;\n                    splatPointer(p);\n                }\n            }\n        }\n        function step(dt) {\n            gl.disable(gl.BLEND);\n            curlProgram.bind();\n            if (curlProgram.uniforms.texelSize) {\n                gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (curlProgram.uniforms.uVelocity) {\n                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            blit(curl);\n            vorticityProgram.bind();\n            if (vorticityProgram.uniforms.texelSize) {\n                gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (vorticityProgram.uniforms.uVelocity) {\n                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            if (vorticityProgram.uniforms.uCurl) {\n                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n            }\n            if (vorticityProgram.uniforms.curl) {\n                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n            }\n            if (vorticityProgram.uniforms.dt) {\n                gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n            }\n            blit(velocity.write);\n            velocity.swap();\n            divergenceProgram.bind();\n            if (divergenceProgram.uniforms.texelSize) {\n                gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (divergenceProgram.uniforms.uVelocity) {\n                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            blit(divergence);\n            clearProgram.bind();\n            if (clearProgram.uniforms.uTexture) {\n                gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n            }\n            if (clearProgram.uniforms.value) {\n                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n            }\n            blit(pressure.write);\n            pressure.swap();\n            pressureProgram.bind();\n            if (pressureProgram.uniforms.texelSize) {\n                gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (pressureProgram.uniforms.uDivergence) {\n                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n            }\n            for(let i = 0; i < config.PRESSURE_ITERATIONS; i++){\n                if (pressureProgram.uniforms.uPressure) {\n                    gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n                }\n                blit(pressure.write);\n                pressure.swap();\n            }\n            gradienSubtractProgram.bind();\n            if (gradienSubtractProgram.uniforms.texelSize) {\n                gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (gradienSubtractProgram.uniforms.uPressure) {\n                gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n            }\n            if (gradienSubtractProgram.uniforms.uVelocity) {\n                gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n            }\n            blit(velocity.write);\n            velocity.swap();\n            advectionProgram.bind();\n            if (advectionProgram.uniforms.texelSize) {\n                gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n            }\n            const velocityId = velocity.read.attach(0);\n            if (advectionProgram.uniforms.uVelocity) {\n                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n            }\n            if (advectionProgram.uniforms.uSource) {\n                gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n            }\n            if (advectionProgram.uniforms.dt) {\n                gl.uniform1f(advectionProgram.uniforms.dt, dt);\n            }\n            if (advectionProgram.uniforms.dissipation) {\n                gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n            }\n            blit(velocity.write);\n            velocity.swap();\n            if (!ext.supportLinearFiltering && advectionProgram.uniforms.dyeTexelSize) {\n                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n            }\n            if (advectionProgram.uniforms.uVelocity) {\n                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n            }\n            if (advectionProgram.uniforms.uSource) {\n                gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n            }\n            if (advectionProgram.uniforms.dissipation) {\n                gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n            }\n            blit(dye.write);\n            dye.swap();\n        }\n        function render(target) {\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n            drawDisplay(target);\n        }\n        function drawDisplay(target) {\n            const width = target ? target.width : gl.drawingBufferWidth;\n            const height = target ? target.height : gl.drawingBufferHeight;\n            displayMaterial.bind();\n            if (config.SHADING && displayMaterial.uniforms.texelSize) {\n                gl.uniform2f(displayMaterial.uniforms.texelSize, 1 / width, 1 / height);\n            }\n            if (displayMaterial.uniforms.uTexture) {\n                gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n            }\n            blit(target, false);\n        }\n        function splatPointer(pointer) {\n            const dx = pointer.deltaX * config.SPLAT_FORCE;\n            const dy = pointer.deltaY * config.SPLAT_FORCE;\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n        }\n        function clickSplat(pointer) {\n            const color = generateColor();\n            color.r *= 10;\n            color.g *= 10;\n            color.b *= 10;\n            const dx = 10 * (Math.random() - 0.5);\n            const dy = 30 * (Math.random() - 0.5);\n            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n        }\n        function splat(x, y, dx, dy, color) {\n            splatProgram.bind();\n            if (splatProgram.uniforms.uTarget) {\n                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n            }\n            if (splatProgram.uniforms.aspectRatio) {\n                gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n            }\n            if (splatProgram.uniforms.point) {\n                gl.uniform2f(splatProgram.uniforms.point, x, y);\n            }\n            if (splatProgram.uniforms.color) {\n                gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0);\n            }\n            if (splatProgram.uniforms.radius) {\n                gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100));\n            }\n            blit(velocity.write);\n            velocity.swap();\n            if (splatProgram.uniforms.uTarget) {\n                gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n            }\n            if (splatProgram.uniforms.color) {\n                gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n            }\n            blit(dye.write);\n            dye.swap();\n        }\n        function correctRadius(radius) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) radius *= aspectRatio;\n            return radius;\n        }\n        function updatePointerDownData(pointer, id, posX, posY) {\n            pointer.id = id;\n            pointer.down = true;\n            pointer.moved = false;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1 - posY / canvas.height;\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.deltaX = 0;\n            pointer.deltaY = 0;\n            pointer.color = generateColor();\n        }\n        function updatePointerMoveData(pointer, posX, posY, color) {\n            pointer.prevTexcoordX = pointer.texcoordX;\n            pointer.prevTexcoordY = pointer.texcoordY;\n            pointer.texcoordX = posX / canvas.width;\n            pointer.texcoordY = 1 - posY / canvas.height;\n            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n            pointer.color = color;\n        }\n        function updatePointerUpData(pointer) {\n            pointer.down = false;\n        }\n        function correctDeltaX(delta) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio < 1) delta *= aspectRatio;\n            return delta;\n        }\n        function correctDeltaY(delta) {\n            const aspectRatio = canvas.width / canvas.height;\n            if (aspectRatio > 1) delta /= aspectRatio;\n            return delta;\n        }\n        function generateColor() {\n            const c = HSVtoRGB(Math.random(), 1.0, 1.0);\n            c.r *= 0.15;\n            c.g *= 0.15;\n            c.b *= 0.15;\n            return c;\n        }\n        function HSVtoRGB(h, s, v) {\n            let r = 0, g = 0, b = 0;\n            const i = Math.floor(h * 6);\n            const f = h * 6 - i;\n            const p = v * (1 - s);\n            const q = v * (1 - f * s);\n            const t = v * (1 - (1 - f) * s);\n            switch(i % 6){\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n            }\n            return {\n                r,\n                g,\n                b\n            };\n        }\n        function wrap(value, min, max) {\n            const range = max - min;\n            if (range === 0) return min;\n            return (value - min) % range + min;\n        }\n        window.addEventListener(\"mousedown\", (e)=>{\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            updatePointerDownData(pointer, -1, posX, posY);\n            clickSplat(pointer);\n        });\n        function handleFirstMouseMove(e) {\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            const color = generateColor();\n            updateFrame();\n            updatePointerMoveData(pointer, posX, posY, color);\n            document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n        }\n        document.body.addEventListener(\"mousemove\", handleFirstMouseMove);\n        window.addEventListener(\"mousemove\", (e)=>{\n            const pointer = pointers[0];\n            const posX = scaleByPixelRatio(e.clientX);\n            const posY = scaleByPixelRatio(e.clientY);\n            const color = pointer.color;\n            updatePointerMoveData(pointer, posX, posY, color);\n        });\n        function handleFirstTouchStart(e) {\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updateFrame();\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n            document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n        }\n        document.body.addEventListener(\"touchstart\", handleFirstTouchStart);\n        window.addEventListener(\"touchstart\", (e)=>{\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n            }\n        }, false);\n        window.addEventListener(\"touchmove\", (e)=>{\n            const touches = e.targetTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                const posX = scaleByPixelRatio(touches[i].clientX);\n                const posY = scaleByPixelRatio(touches[i].clientY);\n                updatePointerMoveData(pointer, posX, posY, pointer.color);\n            }\n        }, false);\n        window.addEventListener(\"touchend\", (e)=>{\n            const touches = e.changedTouches;\n            const pointer = pointers[0];\n            for(let i = 0; i < touches.length; i++){\n                updatePointerUpData(pointer);\n            }\n        });\n    }, [\n        SIM_RESOLUTION,\n        DYE_RESOLUTION,\n        CAPTURE_RESOLUTION,\n        DENSITY_DISSIPATION,\n        VELOCITY_DISSIPATION,\n        PRESSURE,\n        PRESSURE_ITERATIONS,\n        CURL,\n        SPLAT_RADIUS,\n        SPLAT_FORCE,\n        SHADING,\n        COLOR_UPDATE_SPEED,\n        BACK_COLOR,\n        TRANSPARENT\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            id: \"fluid\",\n            className: \"w-screen h-screen block\"\n        }, void 0, false, {\n            fileName: \"/Users/elliott/Downloads/zihao-anime-site/components/SplashCursor.tsx\",\n            lineNumber: 1514,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/elliott/Downloads/zihao-anime-site/components/SplashCursor.tsx\",\n        lineNumber: 1513,\n        columnNumber: 5\n    }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxJQUFJLEdBQUdBLElBQUk0TixRQUFROU4sTUFBTSxFQUFFRSxJQUFLO2dCQUN2QyxNQUFNb00sT0FBT3pELGtCQUFrQmlGLE9BQU8sQ0FBQzVOLEVBQUUsQ0FBQ3FOLE9BQU87Z0JBQ2pELE1BQU1oQixPQUFPMUQsa0JBQWtCaUYsT0FBTyxDQUFDNU4sRUFBRSxDQUFDc04sT0FBTztnQkFDakRoQixzQkFBc0JoQixTQUFTYyxNQUFNQyxNQUFNZixRQUFRMVEsS0FBSztZQUMxRDtRQUNGLEdBQ0E7UUFHRmtPLE9BQU9xRSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUNDO1lBQ25DLE1BQU1RLFVBQVVSLEVBQUVXLGNBQWM7WUFDaEMsTUFBTXpDLFVBQVVwUCxRQUFRLENBQUMsRUFBRTtZQUMzQixJQUFLLElBQUk4RCxJQUFJLEdBQUdBLElBQUk0TixRQUFROU4sTUFBTSxFQUFFRSxJQUFLO2dCQUN2QzBNLG9CQUFvQnBCO1lBQ3RCO1FBQ0Y7SUFDRixHQUFHO1FBQ0RyUTtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztLQUNEO0lBRUQscUJBQ0UsOERBQUNrUztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDalM7WUFDQ2tTLEtBQUtuUztZQUNMNUIsSUFBRztZQUNIOFQsV0FBVTs7Ozs7Ozs7Ozs7QUFJbEI7R0ExN0N3QmpUO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3BsYXNoQ3Vyc29yLnRzeD9hYmQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBDb2xvclJHQiB7XG4gIHI6IG51bWJlcjtcbiAgZzogbnVtYmVyO1xuICBiOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTcGxhc2hDdXJzb3JQcm9wcyB7XG4gIFNJTV9SRVNPTFVUSU9OPzogbnVtYmVyO1xuICBEWUVfUkVTT0xVVElPTj86IG51bWJlcjtcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OPzogbnVtYmVyO1xuICBERU5TSVRZX0RJU1NJUEFUSU9OPzogbnVtYmVyO1xuICBWRUxPQ0lUWV9ESVNTSVBBVElPTj86IG51bWJlcjtcbiAgUFJFU1NVUkU/OiBudW1iZXI7XG4gIFBSRVNTVVJFX0lURVJBVElPTlM/OiBudW1iZXI7XG4gIENVUkw/OiBudW1iZXI7XG4gIFNQTEFUX1JBRElVUz86IG51bWJlcjtcbiAgU1BMQVRfRk9SQ0U/OiBudW1iZXI7XG4gIFNIQURJTkc/OiBib29sZWFuO1xuICBDT0xPUl9VUERBVEVfU1BFRUQ/OiBudW1iZXI7XG4gIEJBQ0tfQ09MT1I/OiBDb2xvclJHQjtcbiAgVFJBTlNQQVJFTlQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgUG9pbnRlciB7XG4gIGlkOiBudW1iZXI7XG4gIHRleGNvb3JkWDogbnVtYmVyO1xuICB0ZXhjb29yZFk6IG51bWJlcjtcbiAgcHJldlRleGNvb3JkWDogbnVtYmVyO1xuICBwcmV2VGV4Y29vcmRZOiBudW1iZXI7XG4gIGRlbHRhWDogbnVtYmVyO1xuICBkZWx0YVk6IG51bWJlcjtcbiAgZG93bjogYm9vbGVhbjtcbiAgbW92ZWQ6IGJvb2xlYW47XG4gIGNvbG9yOiBDb2xvclJHQjtcbn1cblxuZnVuY3Rpb24gcG9pbnRlclByb3RvdHlwZSgpOiBQb2ludGVyIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogLTEsXG4gICAgdGV4Y29vcmRYOiAwLFxuICAgIHRleGNvb3JkWTogMCxcbiAgICBwcmV2VGV4Y29vcmRYOiAwLFxuICAgIHByZXZUZXhjb29yZFk6IDAsXG4gICAgZGVsdGFYOiAwLFxuICAgIGRlbHRhWTogMCxcbiAgICBkb3duOiBmYWxzZSxcbiAgICBtb3ZlZDogZmFsc2UsXG4gICAgY29sb3I6IHsgcjogMCwgZzogMCwgYjogMCB9LFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGxhc2hDdXJzb3Ioe1xuICBTSU1fUkVTT0xVVElPTiA9IDEyOCxcbiAgRFlFX1JFU09MVVRJT04gPSAxNDQwLFxuICBDQVBUVVJFX1JFU09MVVRJT04gPSA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT04gPSAzLjUsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OID0gMixcbiAgUFJFU1NVUkUgPSAwLjEsXG4gIFBSRVNTVVJFX0lURVJBVElPTlMgPSAyMCxcbiAgQ1VSTCA9IDMsXG4gIFNQTEFUX1JBRElVUyA9IDAuMixcbiAgU1BMQVRfRk9SQ0UgPSA2MDAwLFxuICBTSEFESU5HID0gdHJ1ZSxcbiAgQ09MT1JfVVBEQVRFX1NQRUVEID0gMTAsXG4gIEJBQ0tfQ09MT1IgPSB7IHI6IDAuNSwgZzogMCwgYjogMCB9LFxuICBUUkFOU1BBUkVOVCA9IHRydWUsXG59OiBTcGxhc2hDdXJzb3JQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcblxuICAgIGxldCBwb2ludGVyczogUG9pbnRlcltdID0gW3BvaW50ZXJQcm90b3R5cGUoKV07XG5cbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgU0lNX1JFU09MVVRJT046IFNJTV9SRVNPTFVUSU9OISxcbiAgICAgIERZRV9SRVNPTFVUSU9OOiBEWUVfUkVTT0xVVElPTiEsXG4gICAgICBDQVBUVVJFX1JFU09MVVRJT046IENBUFRVUkVfUkVTT0xVVElPTiEsXG4gICAgICBERU5TSVRZX0RJU1NJUEFUSU9OOiBERU5TSVRZX0RJU1NJUEFUSU9OISxcbiAgICAgIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiBWRUxPQ0lUWV9ESVNTSVBBVElPTiEsXG4gICAgICBQUkVTU1VSRTogUFJFU1NVUkUhLFxuICAgICAgUFJFU1NVUkVfSVRFUkFUSU9OUzogUFJFU1NVUkVfSVRFUkFUSU9OUyEsXG4gICAgICBDVVJMOiBDVVJMISxcbiAgICAgIFNQTEFUX1JBRElVUzogU1BMQVRfUkFESVVTISxcbiAgICAgIFNQTEFUX0ZPUkNFOiBTUExBVF9GT1JDRSEsXG4gICAgICBTSEFESU5HLFxuICAgICAgQ09MT1JfVVBEQVRFX1NQRUVEOiBDT0xPUl9VUERBVEVfU1BFRUQhLFxuICAgICAgUEFVU0VEOiBmYWxzZSxcbiAgICAgIEJBQ0tfQ09MT1IsXG4gICAgICBUUkFOU1BBUkVOVCxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBnbCwgZXh0IH0gPSBnZXRXZWJHTENvbnRleHQoY2FudmFzKTtcbiAgICBpZiAoIWdsIHx8ICFleHQpIHJldHVybjtcblxuICAgIGlmICghZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcpIHtcbiAgICAgIGNvbmZpZy5EWUVfUkVTT0xVVElPTiA9IDI1NjtcbiAgICAgIGNvbmZpZy5TSEFESU5HID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICBsZXQgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcbiAgICAgICAgXCJ3ZWJnbDJcIixcbiAgICAgICAgcGFyYW1zXG4gICAgICApIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfCBudWxsO1xuXG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgcGFyYW1zKSB8fFxuICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWwtd2ViZ2xcIixcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICkpIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgfCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMLlwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNXZWJHTDIgPSBcImRyYXdCdWZmZXJzXCIgaW4gZ2w7XG5cbiAgICAgIGxldCBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gZmFsc2U7XG4gICAgICBsZXQgaGFsZkZsb2F0ID0gbnVsbDtcblxuICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpO1xuICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nID0gISEoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZ2V0RXh0ZW5zaW9uKFxuICAgICAgICAgIFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbGZGbG9hdCA9IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7XG4gICAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPSAhIWdsLmdldEV4dGVuc2lvbihcbiAgICAgICAgICBcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcblxuICAgICAgY29uc3QgaGFsZkZsb2F0VGV4VHlwZSA9IGlzV2ViR0wyXG4gICAgICAgID8gKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLkhBTEZfRkxPQVRcbiAgICAgICAgOiAoaGFsZkZsb2F0ICYmIChoYWxmRmxvYXQgYXMgYW55KS5IQUxGX0ZMT0FUX09FUykgfHwgMDtcblxuICAgICAgbGV0IGZvcm1hdFJHQkE6IGFueTtcbiAgICAgIGxldCBmb3JtYXRSRzogYW55O1xuICAgICAgbGV0IGZvcm1hdFI6IGFueTtcblxuICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgIGZvcm1hdFJHQkEgPSBnZXRTdXBwb3J0ZWRGb3JtYXQoXG4gICAgICAgICAgZ2wsXG4gICAgICAgICAgKGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpLlJHQkExNkYsXG4gICAgICAgICAgZ2wuUkdCQSxcbiAgICAgICAgICBoYWxmRmxvYXRUZXhUeXBlXG4gICAgICAgICk7XG4gICAgICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgICAgIGdsLFxuICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRzE2RixcbiAgICAgICAgICAoZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuUkcsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICApO1xuICAgICAgICBmb3JtYXRSID0gZ2V0U3VwcG9ydGVkRm9ybWF0KFxuICAgICAgICAgIGdsLFxuICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SMTZGLFxuICAgICAgICAgIChnbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5SRUQsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0UkdCQSA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQSwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICAgIGZvcm1hdFJHID0gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsLCBnbC5SR0JBLCBnbC5SR0JBLCBoYWxmRmxvYXRUZXhUeXBlKTtcbiAgICAgICAgZm9ybWF0UiA9IGdldFN1cHBvcnRlZEZvcm1hdChnbCwgZ2wuUkdCQSwgZ2wuUkdCQSwgaGFsZkZsb2F0VGV4VHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdsLFxuICAgICAgICBleHQ6IHtcbiAgICAgICAgICBmb3JtYXRSR0JBLFxuICAgICAgICAgIGZvcm1hdFJHLFxuICAgICAgICAgIGZvcm1hdFIsXG4gICAgICAgICAgaGFsZkZsb2F0VGV4VHlwZSxcbiAgICAgICAgICBzdXBwb3J0TGluZWFyRmlsdGVyaW5nLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRGb3JtYXQoXG4gICAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiBudW1iZXIsXG4gICAgICBmb3JtYXQ6IG51bWJlcixcbiAgICAgIHR5cGU6IG51bWJlclxuICAgICk6IHsgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjsgZm9ybWF0OiBudW1iZXIgfSB8IG51bGwge1xuICAgICAgaWYgKCFzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdChnbCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSkpIHtcbiAgICAgICAgaWYgKFwiZHJhd0J1ZmZlcnNcIiBpbiBnbCkge1xuICAgICAgICAgIGNvbnN0IGdsMiA9IGdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICAgICAgc3dpdGNoIChpbnRlcm5hbEZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBnbDIuUjE2RjpcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFN1cHBvcnRlZEZvcm1hdChnbDIsIGdsMi5SRzE2RiwgZ2wyLlJHLCB0eXBlKTtcbiAgICAgICAgICAgIGNhc2UgZ2wyLlJHMTZGOlxuICAgICAgICAgICAgICByZXR1cm4gZ2V0U3VwcG9ydGVkRm9ybWF0KGdsMiwgZ2wyLlJHQkExNkYsIGdsMi5SR0JBLCB0eXBlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGludGVybmFsRm9ybWF0LCBmb3JtYXQgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdChcbiAgICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgICAgIGZvcm1hdDogbnVtYmVyLFxuICAgICAgdHlwZTogbnVtYmVyXG4gICAgKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgaWYgKCF0ZXh0dXJlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICA0LFxuICAgICAgICA0LFxuICAgICAgICAwLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBpZiAoIWZibykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoQ29kZShzOiBzdHJpbmcpIHtcbiAgICAgIGlmICghcy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggfD0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEtleXdvcmRzKHNvdXJjZTogc3RyaW5nLCBrZXl3b3Jkczogc3RyaW5nW10gfCBudWxsKSB7XG4gICAgICBpZiAoIWtleXdvcmRzKSByZXR1cm4gc291cmNlO1xuICAgICAgbGV0IGtleXdvcmRzU3RyaW5nID0gXCJcIjtcbiAgICAgIGZvciAoY29uc3Qga2V5d29yZCBvZiBrZXl3b3Jkcykge1xuICAgICAgICBrZXl3b3Jkc1N0cmluZyArPSBgI2RlZmluZSAke2tleXdvcmR9XFxuYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXl3b3Jkc1N0cmluZyArIHNvdXJjZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKFxuICAgICAgdHlwZTogbnVtYmVyLFxuICAgICAgc291cmNlOiBzdHJpbmcsXG4gICAgICBrZXl3b3Jkczogc3RyaW5nW10gfCBudWxsID0gbnVsbFxuICAgICk6IFdlYkdMU2hhZGVyIHwgbnVsbCB7XG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBhZGRLZXl3b3Jkcyhzb3VyY2UsIGtleXdvcmRzKTtcbiAgICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyIHwgbnVsbCxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlciB8IG51bGxcbiAgICApOiBXZWJHTFByb2dyYW0gfCBudWxsIHtcbiAgICAgIGlmICghdmVydGV4U2hhZGVyIHx8ICFmcmFnbWVudFNoYWRlcikgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFVuaWZvcm1zKHByb2dyYW06IFdlYkdMUHJvZ3JhbSkge1xuICAgICAgbGV0IHVuaWZvcm1zOiBSZWNvcmQ8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB8IG51bGw+ID0ge307XG4gICAgICBjb25zdCB1bmlmb3JtQ291bnQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1JbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICAgICAgaWYgKHVuaWZvcm1JbmZvKSB7XG4gICAgICAgICAgdW5pZm9ybXNbdW5pZm9ybUluZm8ubmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oXG4gICAgICAgICAgICBwcm9ncmFtLFxuICAgICAgICAgICAgdW5pZm9ybUluZm8ubmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmlmb3JtcztcbiAgICB9XG5cbiAgICBjbGFzcyBQcm9ncmFtIHtcbiAgICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbSB8IG51bGw7XG4gICAgICB1bmlmb3JtczogUmVjb3JkPHN0cmluZywgV2ViR0xVbmlmb3JtTG9jYXRpb24gfCBudWxsPjtcblxuICAgICAgY29uc3RydWN0b3IoXG4gICAgICAgIHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHRoaXMucHJvZ3JhbSA/IGdldFVuaWZvcm1zKHRoaXMucHJvZ3JhbSkgOiB7fTtcbiAgICAgIH1cblxuICAgICAgYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSkgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIE1hdGVyaWFsIHtcbiAgICAgIHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsO1xuICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZztcbiAgICAgIHByb2dyYW1zOiBSZWNvcmQ8bnVtYmVyLCBXZWJHTFByb2dyYW0gfCBudWxsPjtcbiAgICAgIGFjdGl2ZVByb2dyYW06IFdlYkdMUHJvZ3JhbSB8IG51bGw7XG4gICAgICB1bmlmb3JtczogUmVjb3JkPHN0cmluZywgV2ViR0xVbmlmb3JtTG9jYXRpb24gfCBudWxsPjtcblxuICAgICAgY29uc3RydWN0b3IoXG4gICAgICAgIHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgfCBudWxsLFxuICAgICAgICBmcmFnbWVudFNoYWRlclNvdXJjZTogc3RyaW5nXG4gICAgICApIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZTtcbiAgICAgICAgdGhpcy5wcm9ncmFtcyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgICB9XG5cbiAgICAgIHNldEtleXdvcmRzKGtleXdvcmRzOiBzdHJpbmdbXSkge1xuICAgICAgICBsZXQgaGFzaCA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qga3cgb2Yga2V5d29yZHMpIHtcbiAgICAgICAgICBoYXNoICs9IGhhc2hDb2RlKGt3KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbaGFzaF07XG4gICAgICAgIGlmIChwcm9ncmFtID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlLFxuICAgICAgICAgICAga2V5d29yZHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgdGhpcy5wcm9ncmFtc1toYXNoXSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gPT09IHRoaXMuYWN0aXZlUHJvZ3JhbSkgcmV0dXJuO1xuICAgICAgICBpZiAocHJvZ3JhbSkge1xuICAgICAgICAgIHRoaXMudW5pZm9ybXMgPSBnZXRVbmlmb3Jtcyhwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgfVxuXG4gICAgICBiaW5kKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVQcm9ncmFtKSB7XG4gICAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLmFjdGl2ZVByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5WRVJURVhfU0hBREVSLFxuICAgICAgYFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZVdiA9IGFQb3NpdGlvbiAqIDAuNSArIDAuNTtcbiAgICAgICAgdkwgPSB2VXYgLSB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICB2UiA9IHZVdiArIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgIHZUID0gdlV2ICsgdmVjMigwLjAsIHRleGVsU2l6ZS55KTtcbiAgICAgICAgdkIgPSB2VXYgLSB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBjb3B5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGNsZWFyU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2YWx1ZSAqIHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGRpc3BsYXlTaGFkZXJTb3VyY2UgPSBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdGhlcmluZztcbiAgICAgIHVuaWZvcm0gdmVjMiBkaXRoZXJTY2FsZTtcbiAgICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG5cbiAgICAgIHZlYzMgbGluZWFyVG9HYW1tYSAodmVjMyBjb2xvcikge1xuICAgICAgICAgIGNvbG9yID0gbWF4KGNvbG9yLCB2ZWMzKDApKTtcbiAgICAgICAgICByZXR1cm4gbWF4KDEuMDU1ICogcG93KGNvbG9yLCB2ZWMzKDAuNDE2NjY2NjY3KSkgLSAwLjA1NSwgdmVjMygwKSk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgdmVjMyBjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VXYpLnJnYjtcbiAgICAgICAgICAjaWZkZWYgU0hBRElOR1xuICAgICAgICAgICAgICB2ZWMzIGxjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2TCkucmdiO1xuICAgICAgICAgICAgICB2ZWMzIHJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2UikucmdiO1xuICAgICAgICAgICAgICB2ZWMzIHRjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VCkucmdiO1xuICAgICAgICAgICAgICB2ZWMzIGJjID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2QikucmdiO1xuXG4gICAgICAgICAgICAgIGZsb2F0IGR4ID0gbGVuZ3RoKHJjKSAtIGxlbmd0aChsYyk7XG4gICAgICAgICAgICAgIGZsb2F0IGR5ID0gbGVuZ3RoKHRjKSAtIGxlbmd0aChiYyk7XG5cbiAgICAgICAgICAgICAgdmVjMyBuID0gbm9ybWFsaXplKHZlYzMoZHgsIGR5LCBsZW5ndGgodGV4ZWxTaXplKSkpO1xuICAgICAgICAgICAgICB2ZWMzIGwgPSB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICAgIGZsb2F0IGRpZmZ1c2UgPSBjbGFtcChkb3QobiwgbCkgKyAwLjcsIDAuNywgMS4wKTtcbiAgICAgICAgICAgICAgYyAqPSBkaWZmdXNlO1xuICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgZmxvYXQgYSA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgYSk7XG4gICAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IHNwbGF0U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRhcmdldDtcbiAgICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgICB1bmlmb3JtIHZlYzMgY29sb3I7XG4gICAgICB1bmlmb3JtIHZlYzIgcG9pbnQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICB2ZWMyIHAgPSB2VXYgLSBwb2ludC54eTtcbiAgICAgICAgICBwLnggKj0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgdmVjMyBzcGxhdCA9IGV4cCgtZG90KHAsIHApIC8gcmFkaXVzKSAqIGNvbG9yO1xuICAgICAgICAgIHZlYzMgYmFzZSA9IHRleHR1cmUyRCh1VGFyZ2V0LCB2VXYpLnh5ejtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGJhc2UgKyBzcGxhdCwgMS4wKTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGFkdmVjdGlvblNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTb3VyY2U7XG4gICAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICAgICAgdW5pZm9ybSB2ZWMyIGR5ZVRleGVsU2l6ZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgZHQ7XG4gICAgICB1bmlmb3JtIGZsb2F0IGRpc3NpcGF0aW9uO1xuXG4gICAgICB2ZWM0IGJpbGVycCAoc2FtcGxlcjJEIHNhbSwgdmVjMiB1diwgdmVjMiB0c2l6ZSkge1xuICAgICAgICAgIHZlYzIgc3QgPSB1diAvIHRzaXplIC0gMC41O1xuICAgICAgICAgIHZlYzIgaXV2ID0gZmxvb3Ioc3QpO1xuICAgICAgICAgIHZlYzIgZnV2ID0gZnJhY3Qoc3QpO1xuXG4gICAgICAgICAgdmVjNCBhID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMC41LCAwLjUpKSAqIHRzaXplKTtcbiAgICAgICAgICB2ZWM0IGIgPSB0ZXh0dXJlMkQoc2FtLCAoaXV2ICsgdmVjMigxLjUsIDAuNSkpICogdHNpemUpO1xuICAgICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgICAgdmVjNCBkID0gdGV4dHVyZTJEKHNhbSwgKGl1diArIHZlYzIoMS41LCAxLjUpKSAqIHRzaXplKTtcblxuICAgICAgICAgIHJldHVybiBtaXgobWl4KGEsIGIsIGZ1di54KSwgbWl4KGMsIGQsIGZ1di54KSwgZnV2LnkpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICNpZmRlZiBNQU5VQUxfRklMVEVSSU5HXG4gICAgICAgICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIGJpbGVycCh1VmVsb2NpdHksIHZVdiwgdGV4ZWxTaXplKS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgdmVjNCByZXN1bHQgPSBiaWxlcnAodVNvdXJjZSwgY29vcmQsIGR5ZVRleGVsU2l6ZSk7XG4gICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgdmVjMiBjb29yZCA9IHZVdiAtIGR0ICogdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eSAqIHRleGVsU2l6ZTtcbiAgICAgICAgICAgICAgdmVjNCByZXN1bHQgPSB0ZXh0dXJlMkQodVNvdXJjZSwgY29vcmQpO1xuICAgICAgICAgICNlbmRpZlxuICAgICAgICAgIGZsb2F0IGRlY2F5ID0gMS4wICsgZGlzc2lwYXRpb24gKiBkdDtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQgLyBkZWNheTtcbiAgICAgIH1cbiAgICBgLFxuICAgICAgZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyBudWxsIDogW1wiTUFOVUFMX0ZJTFRFUklOR1wiXVxuICAgICk7XG5cbiAgICBjb25zdCBkaXZlcmdlbmNlU2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2TDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2QjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkwpLng7XG4gICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZSKS54O1xuICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueTtcbiAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdkIpLnk7XG5cbiAgICAgICAgICB2ZWMyIEMgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICAgIGlmICh2TC54IDwgMC4wKSB7IEwgPSAtQy54OyB9XG4gICAgICAgICAgaWYgKHZSLnggPiAxLjApIHsgUiA9IC1DLng7IH1cbiAgICAgICAgICBpZiAodlQueSA+IDEuMCkgeyBUID0gLUMueTsgfVxuICAgICAgICAgIGlmICh2Qi55IDwgMC4wKSB7IEIgPSAtQy55OyB9XG5cbiAgICAgICAgICBmbG9hdCBkaXYgPSAwLjUgKiAoUiAtIEwgKyBUIC0gQik7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkaXYsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgY3VybFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS55O1xuICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2UikueTtcbiAgICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlQpLng7XG4gICAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS54O1xuICAgICAgICAgIGZsb2F0IHZvcnRpY2l0eSA9IFIgLSBMIC0gVCArIEI7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjUgKiB2b3J0aWNpdHksIDAuMCwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGBcbiAgICApO1xuXG4gICAgY29uc3Qgdm9ydGljaXR5U2hhZGVyID0gY29tcGlsZVNoYWRlcihcbiAgICAgIGdsLkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdUN1cmw7XG4gICAgICB1bmlmb3JtIGZsb2F0IGN1cmw7XG4gICAgICB1bmlmb3JtIGZsb2F0IGR0O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodUN1cmwsIHZMKS54O1xuICAgICAgICAgIGZsb2F0IFIgPSB0ZXh0dXJlMkQodUN1cmwsIHZSKS54O1xuICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodUN1cmwsIHZUKS54O1xuICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodUN1cmwsIHZCKS54O1xuICAgICAgICAgIGZsb2F0IEMgPSB0ZXh0dXJlMkQodUN1cmwsIHZVdikueDtcblxuICAgICAgICAgIHZlYzIgZm9yY2UgPSAwLjUgKiB2ZWMyKGFicyhUKSAtIGFicyhCKSwgYWJzKFIpIC0gYWJzKEwpKTtcbiAgICAgICAgICBmb3JjZSAvPSBsZW5ndGgoZm9yY2UpICsgMC4wMDAxO1xuICAgICAgICAgIGZvcmNlICo9IGN1cmwgKiBDO1xuICAgICAgICAgIGZvcmNlLnkgKj0gLTEuMDtcblxuICAgICAgICAgIHZlYzIgdmVsb2NpdHkgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICAgIHZlbG9jaXR5ICs9IGZvcmNlICogZHQ7XG4gICAgICAgICAgdmVsb2NpdHkgPSBtaW4obWF4KHZlbG9jaXR5LCAtMTAwMC4wKSwgMTAwMC4wKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlbG9jaXR5LCAwLjAsIDEuMCk7XG4gICAgICB9XG4gICAgYFxuICAgICk7XG5cbiAgICBjb25zdCBwcmVzc3VyZVNoYWRlciA9IGNvbXBpbGVTaGFkZXIoXG4gICAgICBnbC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcbiAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlI7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1UHJlc3N1cmU7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl2ZXJnZW5jZTtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICBmbG9hdCBMID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkwpLng7XG4gICAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2VCkueDtcbiAgICAgICAgICBmbG9hdCBCID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdkIpLng7XG4gICAgICAgICAgZmxvYXQgQyA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZVdikueDtcbiAgICAgICAgICBmbG9hdCBkaXZlcmdlbmNlID0gdGV4dHVyZTJEKHVEaXZlcmdlbmNlLCB2VXYpLng7XG4gICAgICAgICAgZmxvYXQgcHJlc3N1cmUgPSAoTCArIFIgKyBCICsgVCAtIGRpdmVyZ2VuY2UpICogMC4yNTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHByZXNzdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgIH1cbiAgICBgXG4gICAgKTtcblxuICAgIGNvbnN0IGdyYWRpZW50U3VidHJhY3RTaGFkZXIgPSBjb21waWxlU2hhZGVyKFxuICAgICAgZ2wuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG4gICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlV2O1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUO1xuICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2TCkueDtcbiAgICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlIpLng7XG4gICAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZUKS54O1xuICAgICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2QikueDtcbiAgICAgICAgICB2ZWMyIHZlbG9jaXR5ID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlV2KS54eTtcbiAgICAgICAgICB2ZWxvY2l0eS54eSAtPSB2ZWMyKFIgLSBMLCBUIC0gQik7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgICAgfVxuICAgIGBcbiAgICApO1xuXG4gICAgY29uc3QgYmxpdCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKSE7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoXG4gICAgICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgLTFdKSxcbiAgICAgICAgZ2wuU1RBVElDX0RSQVdcbiAgICAgICk7XG4gICAgICBjb25zdCBlbGVtQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCkhO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbUJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbiAgICAgICAgbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSksXG4gICAgICAgIGdsLlNUQVRJQ19EUkFXXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcigwLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMCk7XG5cbiAgICAgIHJldHVybiAodGFyZ2V0OiBGQk8gfCBudWxsLCBkb0NsZWFyID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0YXJnZXQud2lkdGgsIHRhcmdldC5oZWlnaHQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGFyZ2V0LmZibyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvQ2xlYXIpIHtcbiAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xuICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGludGVyZmFjZSBGQk8ge1xuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlO1xuICAgICAgZmJvOiBXZWJHTEZyYW1lYnVmZmVyO1xuICAgICAgd2lkdGg6IG51bWJlcjtcbiAgICAgIGhlaWdodDogbnVtYmVyO1xuICAgICAgdGV4ZWxTaXplWDogbnVtYmVyO1xuICAgICAgdGV4ZWxTaXplWTogbnVtYmVyO1xuICAgICAgYXR0YWNoOiAoaWQ6IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIH1cblxuICAgIGludGVyZmFjZSBEb3VibGVGQk8ge1xuICAgICAgd2lkdGg6IG51bWJlcjtcbiAgICAgIGhlaWdodDogbnVtYmVyO1xuICAgICAgdGV4ZWxTaXplWDogbnVtYmVyO1xuICAgICAgdGV4ZWxTaXplWTogbnVtYmVyO1xuICAgICAgcmVhZDogRkJPO1xuICAgICAgd3JpdGU6IEZCTztcbiAgICAgIHN3YXA6ICgpID0+IHZvaWQ7XG4gICAgfVxuXG4gICAgbGV0IGR5ZTogRG91YmxlRkJPO1xuICAgIGxldCB2ZWxvY2l0eTogRG91YmxlRkJPO1xuICAgIGxldCBkaXZlcmdlbmNlOiBGQk87XG4gICAgbGV0IGN1cmw6IEZCTztcbiAgICBsZXQgcHJlc3N1cmU6IERvdWJsZUZCTztcblxuICAgIGNvbnN0IGNvcHlQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY29weVNoYWRlcik7XG4gICAgY29uc3QgY2xlYXJQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY2xlYXJTaGFkZXIpO1xuICAgIGNvbnN0IHNwbGF0UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHNwbGF0U2hhZGVyKTtcbiAgICBjb25zdCBhZHZlY3Rpb25Qcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgYWR2ZWN0aW9uU2hhZGVyKTtcbiAgICBjb25zdCBkaXZlcmdlbmNlUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIGRpdmVyZ2VuY2VTaGFkZXIpO1xuICAgIGNvbnN0IGN1cmxQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgY3VybFNoYWRlcik7XG4gICAgY29uc3Qgdm9ydGljaXR5UHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGJhc2VWZXJ0ZXhTaGFkZXIsIHZvcnRpY2l0eVNoYWRlcik7XG4gICAgY29uc3QgcHJlc3N1cmVQcm9ncmFtID0gbmV3IFByb2dyYW0oYmFzZVZlcnRleFNoYWRlciwgcHJlc3N1cmVTaGFkZXIpO1xuICAgIGNvbnN0IGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0gPSBuZXcgUHJvZ3JhbShcbiAgICAgIGJhc2VWZXJ0ZXhTaGFkZXIsXG4gICAgICBncmFkaWVudFN1YnRyYWN0U2hhZGVyXG4gICAgKTtcbiAgICBjb25zdCBkaXNwbGF5TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoYmFzZVZlcnRleFNoYWRlciwgZGlzcGxheVNoYWRlclNvdXJjZSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGQk8oXG4gICAgICB3OiBudW1iZXIsXG4gICAgICBoOiBudW1iZXIsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyLFxuICAgICAgZm9ybWF0OiBudW1iZXIsXG4gICAgICB0eXBlOiBudW1iZXIsXG4gICAgICBwYXJhbTogbnVtYmVyXG4gICAgKTogRkJPIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKSE7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW0pO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICAwLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICBjb25zdCBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpITtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB3LCBoKTtcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gICAgICBjb25zdCB0ZXhlbFNpemVYID0gMSAvIHc7XG4gICAgICBjb25zdCB0ZXhlbFNpemVZID0gMSAvIGg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIGZibyxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgdGV4ZWxTaXplWCxcbiAgICAgICAgdGV4ZWxTaXplWSxcbiAgICAgICAgYXR0YWNoKGlkOiBudW1iZXIpIHtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaWQpO1xuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRG91YmxlRkJPKFxuICAgICAgdzogbnVtYmVyLFxuICAgICAgaDogbnVtYmVyLFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgICAgIGZvcm1hdDogbnVtYmVyLFxuICAgICAgdHlwZTogbnVtYmVyLFxuICAgICAgcGFyYW06IG51bWJlclxuICAgICk6IERvdWJsZUZCTyB7XG4gICAgICBjb25zdCBmYm8xID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIGNvbnN0IGZibzIgPSBjcmVhdGVGQk8odywgaCwgaW50ZXJuYWxGb3JtYXQsIGZvcm1hdCwgdHlwZSwgcGFyYW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgdGV4ZWxTaXplWDogZmJvMS50ZXhlbFNpemVYLFxuICAgICAgICB0ZXhlbFNpemVZOiBmYm8xLnRleGVsU2l6ZVksXG4gICAgICAgIHJlYWQ6IGZibzEsXG4gICAgICAgIHdyaXRlOiBmYm8yLFxuICAgICAgICBzd2FwKCkge1xuICAgICAgICAgIGNvbnN0IHRtcCA9IHRoaXMucmVhZDtcbiAgICAgICAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlO1xuICAgICAgICAgIHRoaXMud3JpdGUgPSB0bXA7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUZCTyhcbiAgICAgIHRhcmdldDogRkJPLFxuICAgICAgdzogbnVtYmVyLFxuICAgICAgaDogbnVtYmVyLFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgICAgIGZvcm1hdDogbnVtYmVyLFxuICAgICAgdHlwZTogbnVtYmVyLFxuICAgICAgcGFyYW06IG51bWJlclxuICAgICkge1xuICAgICAgY29uc3QgbmV3RkJPID0gY3JlYXRlRkJPKHcsIGgsIGludGVybmFsRm9ybWF0LCBmb3JtYXQsIHR5cGUsIHBhcmFtKTtcbiAgICAgIGNvcHlQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChjb3B5UHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSlcbiAgICAgICAgZ2wudW5pZm9ybTFpKGNvcHlQcm9ncmFtLnVuaWZvcm1zLnVUZXh0dXJlLCB0YXJnZXQuYXR0YWNoKDApKTtcbiAgICAgIGJsaXQobmV3RkJPLCBmYWxzZSk7XG4gICAgICByZXR1cm4gbmV3RkJPO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgIHRhcmdldDogRG91YmxlRkJPLFxuICAgICAgdzogbnVtYmVyLFxuICAgICAgaDogbnVtYmVyLFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcixcbiAgICAgIGZvcm1hdDogbnVtYmVyLFxuICAgICAgdHlwZTogbnVtYmVyLFxuICAgICAgcGFyYW06IG51bWJlclxuICAgICkge1xuICAgICAgaWYgKHRhcmdldC53aWR0aCA9PT0gdyAmJiB0YXJnZXQuaGVpZ2h0ID09PSBoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0LnJlYWQgPSByZXNpemVGQk8oXG4gICAgICAgIHRhcmdldC5yZWFkLFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBwYXJhbVxuICAgICAgKTtcbiAgICAgIHRhcmdldC53cml0ZSA9IGNyZWF0ZUZCTyh3LCBoLCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0LCB0eXBlLCBwYXJhbSk7XG4gICAgICB0YXJnZXQud2lkdGggPSB3O1xuICAgICAgdGFyZ2V0LmhlaWdodCA9IGg7XG4gICAgICB0YXJnZXQudGV4ZWxTaXplWCA9IDEgLyB3O1xuICAgICAgdGFyZ2V0LnRleGVsU2l6ZVkgPSAxIC8gaDtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEZyYW1lYnVmZmVycygpIHtcbiAgICAgIGNvbnN0IHNpbVJlcyA9IGdldFJlc29sdXRpb24oY29uZmlnLlNJTV9SRVNPTFVUSU9OISk7XG4gICAgICBjb25zdCBkeWVSZXMgPSBnZXRSZXNvbHV0aW9uKGNvbmZpZy5EWUVfUkVTT0xVVElPTiEpO1xuXG4gICAgICBjb25zdCB0ZXhUeXBlID0gZXh0LmhhbGZGbG9hdFRleFR5cGU7XG4gICAgICBjb25zdCByZ2JhID0gZXh0LmZvcm1hdFJHQkE7XG4gICAgICBjb25zdCByZyA9IGV4dC5mb3JtYXRSRztcbiAgICAgIGNvbnN0IHIgPSBleHQuZm9ybWF0UjtcbiAgICAgIGNvbnN0IGZpbHRlcmluZyA9IGV4dC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgICBpZiAoIWR5ZSkge1xuICAgICAgICBkeWUgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICAgICAgZHllUmVzLndpZHRoLFxuICAgICAgICAgIGR5ZVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmdiYS5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZ2JhLmZvcm1hdCxcbiAgICAgICAgICB0ZXhUeXBlLFxuICAgICAgICAgIGZpbHRlcmluZ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHllID0gcmVzaXplRG91YmxlRkJPKFxuICAgICAgICAgIGR5ZSxcbiAgICAgICAgICBkeWVSZXMud2lkdGgsXG4gICAgICAgICAgZHllUmVzLmhlaWdodCxcbiAgICAgICAgICByZ2JhLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHJnYmEuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZmlsdGVyaW5nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmVsb2NpdHkpIHtcbiAgICAgICAgdmVsb2NpdHkgPSBjcmVhdGVEb3VibGVGQk8oXG4gICAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICAgIHNpbVJlcy5oZWlnaHQsXG4gICAgICAgICAgcmcuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgcmcuZm9ybWF0LFxuICAgICAgICAgIHRleFR5cGUsXG4gICAgICAgICAgZmlsdGVyaW5nXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZWxvY2l0eSA9IHJlc2l6ZURvdWJsZUZCTyhcbiAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICBzaW1SZXMud2lkdGgsXG4gICAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgICByZy5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgICByZy5mb3JtYXQsXG4gICAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgICBmaWx0ZXJpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZGl2ZXJnZW5jZSA9IGNyZWF0ZUZCTyhcbiAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICByLmZvcm1hdCxcbiAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgKTtcbiAgICAgIGN1cmwgPSBjcmVhdGVGQk8oXG4gICAgICAgIHNpbVJlcy53aWR0aCxcbiAgICAgICAgc2ltUmVzLmhlaWdodCxcbiAgICAgICAgci5pbnRlcm5hbEZvcm1hdCxcbiAgICAgICAgci5mb3JtYXQsXG4gICAgICAgIHRleFR5cGUsXG4gICAgICAgIGdsLk5FQVJFU1RcbiAgICAgICk7XG4gICAgICBwcmVzc3VyZSA9IGNyZWF0ZURvdWJsZUZCTyhcbiAgICAgICAgc2ltUmVzLndpZHRoLFxuICAgICAgICBzaW1SZXMuaGVpZ2h0LFxuICAgICAgICByLmludGVybmFsRm9ybWF0LFxuICAgICAgICByLmZvcm1hdCxcbiAgICAgICAgdGV4VHlwZSxcbiAgICAgICAgZ2wuTkVBUkVTVFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVLZXl3b3JkcygpIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlLZXl3b3Jkczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGlmIChjb25maWcuU0hBRElORykgZGlzcGxheUtleXdvcmRzLnB1c2goXCJTSEFESU5HXCIpO1xuICAgICAgZGlzcGxheU1hdGVyaWFsLnNldEtleXdvcmRzKGRpc3BsYXlLZXl3b3Jkcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IHcgPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgICBjb25zdCBoID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gdyAvIGg7XG4gICAgICBsZXQgYXNwZWN0ID0gYXNwZWN0UmF0aW8gPCAxID8gMSAvIGFzcGVjdFJhdGlvIDogYXNwZWN0UmF0aW87XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLnJvdW5kKHJlc29sdXRpb24pO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5yb3VuZChyZXNvbHV0aW9uICogYXNwZWN0KTtcbiAgICAgIGlmICh3ID4gaCkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogbWF4LCBoZWlnaHQ6IG1pbiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IG1pbiwgaGVpZ2h0OiBtYXggfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZUJ5UGl4ZWxSYXRpbyhpbnB1dDogbnVtYmVyKSB7XG4gICAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGlucHV0ICogcGl4ZWxSYXRpbyk7XG4gICAgfVxuXG4gICAgdXBkYXRlS2V5d29yZHMoKTtcbiAgICBpbml0RnJhbWVidWZmZXJzKCk7XG5cbiAgICBsZXQgbGFzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjb2xvclVwZGF0ZVRpbWVyID0gMC4wO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlRnJhbWUoKSB7XG4gICAgICBjb25zdCBkdCA9IGNhbGNEZWx0YVRpbWUoKTtcbiAgICAgIGlmIChyZXNpemVDYW52YXMoKSkgaW5pdEZyYW1lYnVmZmVycygpO1xuICAgICAgdXBkYXRlQ29sb3JzKGR0KTtcbiAgICAgIGFwcGx5SW5wdXRzKCk7XG4gICAgICBzdGVwKGR0KTtcbiAgICAgIHJlbmRlcihudWxsKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVGcmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0RlbHRhVGltZSgpIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBsZXQgZHQgPSAobm93IC0gbGFzdFVwZGF0ZVRpbWUpIC8gMTAwMDtcbiAgICAgIGR0ID0gTWF0aC5taW4oZHQsIDAuMDE2NjY2KTtcbiAgICAgIGxhc3RVcGRhdGVUaW1lID0gbm93O1xuICAgICAgcmV0dXJuIGR0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gc2NhbGVCeVBpeGVsUmF0aW8oY2FudmFzIS5jbGllbnRXaWR0aCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhjYW52YXMhLmNsaWVudEhlaWdodCk7XG4gICAgICBpZiAoY2FudmFzIS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzIS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMhLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcyEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb2xvcnMoZHQ6IG51bWJlcikge1xuICAgICAgY29sb3JVcGRhdGVUaW1lciArPSBkdCAqIGNvbmZpZy5DT0xPUl9VUERBVEVfU1BFRUQ7XG4gICAgICBpZiAoY29sb3JVcGRhdGVUaW1lciA+PSAxKSB7XG4gICAgICAgIGNvbG9yVXBkYXRlVGltZXIgPSB3cmFwKGNvbG9yVXBkYXRlVGltZXIsIDAsIDEpO1xuICAgICAgICBwb2ludGVycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgcC5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlJbnB1dHMoKSB7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcG9pbnRlcnMpIHtcbiAgICAgICAgaWYgKHAubW92ZWQpIHtcbiAgICAgICAgICBwLm1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgc3BsYXRQb2ludGVyKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcChkdDogbnVtYmVyKSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgY3VybFByb2dyYW0uYmluZCgpO1xuICAgICAgaWYgKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgY3VybFByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGN1cmxQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSkge1xuICAgICAgICBnbC51bmlmb3JtMWkoY3VybFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKSk7XG4gICAgICB9XG4gICAgICBibGl0KGN1cmwpO1xuXG4gICAgICB2b3J0aWNpdHlQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmICh2b3J0aWNpdHlQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgdm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51Q3VybCkge1xuICAgICAgICBnbC51bmlmb3JtMWkodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy51Q3VybCwgY3VybC5hdHRhY2goMSkpO1xuICAgICAgfVxuICAgICAgaWYgKHZvcnRpY2l0eVByb2dyYW0udW5pZm9ybXMuY3VybCkge1xuICAgICAgICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5jdXJsLCBjb25maWcuQ1VSTCk7XG4gICAgICB9XG4gICAgICBpZiAodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5kdCkge1xuICAgICAgICBnbC51bmlmb3JtMWYodm9ydGljaXR5UHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpO1xuICAgICAgfVxuICAgICAgYmxpdCh2ZWxvY2l0eS53cml0ZSk7XG4gICAgICB2ZWxvY2l0eS5zd2FwKCk7XG5cbiAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXZlcmdlbmNlUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIGRpdmVyZ2VuY2VQcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSxcbiAgICAgICAgICB2ZWxvY2l0eS5yZWFkLmF0dGFjaCgwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYmxpdChkaXZlcmdlbmNlKTtcblxuICAgICAgY2xlYXJQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChjbGVhclByb2dyYW0udW5pZm9ybXMudVRleHR1cmUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy51VGV4dHVyZSwgcHJlc3N1cmUucmVhZC5hdHRhY2goMCkpO1xuICAgICAgfVxuICAgICAgaWYgKGNsZWFyUHJvZ3JhbS51bmlmb3Jtcy52YWx1ZSkge1xuICAgICAgICBnbC51bmlmb3JtMWYoY2xlYXJQcm9ncmFtLnVuaWZvcm1zLnZhbHVlLCBjb25maWcuUFJFU1NVUkUpO1xuICAgICAgfVxuICAgICAgYmxpdChwcmVzc3VyZS53cml0ZSk7XG4gICAgICBwcmVzc3VyZS5zd2FwKCk7XG5cbiAgICAgIHByZXNzdXJlUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAocHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgcHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVYLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudURpdmVyZ2VuY2UpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIHByZXNzdXJlUHJvZ3JhbS51bmlmb3Jtcy51RGl2ZXJnZW5jZSxcbiAgICAgICAgICBkaXZlcmdlbmNlLmF0dGFjaCgwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuUFJFU1NVUkVfSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVzc3VyZVByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlKSB7XG4gICAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgICAgcHJlc3N1cmVQcm9ncmFtLnVuaWZvcm1zLnVQcmVzc3VyZSxcbiAgICAgICAgICAgIHByZXNzdXJlLnJlYWQuYXR0YWNoKDEpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBibGl0KHByZXNzdXJlLndyaXRlKTtcbiAgICAgICAgcHJlc3N1cmUuc3dhcCgpO1xuICAgICAgfVxuXG4gICAgICBncmFkaWVuU3VidHJhY3RQcm9ncmFtLmJpbmQoKTtcbiAgICAgIGlmIChncmFkaWVuU3VidHJhY3RQcm9ncmFtLnVuaWZvcm1zLnRleGVsU2l6ZSkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51UHJlc3N1cmUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVByZXNzdXJlLFxuICAgICAgICAgIHByZXNzdXJlLnJlYWQuYXR0YWNoKDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhZGllblN1YnRyYWN0UHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKFxuICAgICAgICAgIGdyYWRpZW5TdWJ0cmFjdFByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LFxuICAgICAgICAgIHZlbG9jaXR5LnJlYWQuYXR0YWNoKDEpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS5iaW5kKCk7XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy50ZXhlbFNpemUpIHtcbiAgICAgICAgZ2wudW5pZm9ybTJmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudGV4ZWxTaXplLFxuICAgICAgICAgIHZlbG9jaXR5LnRleGVsU2l6ZVgsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAhZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgJiZcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemVcbiAgICAgICkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsXG4gICAgICAgICAgdmVsb2NpdHkudGV4ZWxTaXplWCxcbiAgICAgICAgICB2ZWxvY2l0eS50ZXhlbFNpemVZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB2ZWxvY2l0eUlkID0gdmVsb2NpdHkucmVhZC5hdHRhY2goMCk7XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHkpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVZlbG9jaXR5LCB2ZWxvY2l0eUlkKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgdmVsb2NpdHlJZCk7XG4gICAgICB9XG4gICAgICBpZiAoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kdCkge1xuICAgICAgICBnbC51bmlmb3JtMWYoYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5kdCwgZHQpO1xuICAgICAgfVxuICAgICAgaWYgKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24pIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICAgIGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMuZGlzc2lwYXRpb24sXG4gICAgICAgICAgY29uZmlnLlZFTE9DSVRZX0RJU1NJUEFUSU9OXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgaWYgKFxuICAgICAgICAhZXh0LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgJiZcbiAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemVcbiAgICAgICkge1xuICAgICAgICBnbC51bmlmb3JtMmYoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy5keWVUZXhlbFNpemUsXG4gICAgICAgICAgZHllLnRleGVsU2l6ZVgsXG4gICAgICAgICAgZHllLnRleGVsU2l6ZVlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVWZWxvY2l0eSkge1xuICAgICAgICBnbC51bmlmb3JtMWkoXG4gICAgICAgICAgYWR2ZWN0aW9uUHJvZ3JhbS51bmlmb3Jtcy51VmVsb2NpdHksXG4gICAgICAgICAgdmVsb2NpdHkucmVhZC5hdHRhY2goMClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLnVTb3VyY2UpIHtcbiAgICAgICAgZ2wudW5pZm9ybTFpKGFkdmVjdGlvblByb2dyYW0udW5pZm9ybXMudVNvdXJjZSwgZHllLnJlYWQuYXR0YWNoKDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgICBhZHZlY3Rpb25Qcm9ncmFtLnVuaWZvcm1zLmRpc3NpcGF0aW9uLFxuICAgICAgICAgIGNvbmZpZy5ERU5TSVRZX0RJU1NJUEFUSU9OXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBibGl0KGR5ZS53cml0ZSk7XG4gICAgICBkeWUuc3dhcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcih0YXJnZXQ6IEZCTyB8IG51bGwpIHtcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgIGRyYXdEaXNwbGF5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0Rpc3BsYXkodGFyZ2V0OiBGQk8gfCBudWxsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRhcmdldCA/IHRhcmdldC53aWR0aCA6IGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRhcmdldCA/IHRhcmdldC5oZWlnaHQgOiBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgICAgZGlzcGxheU1hdGVyaWFsLmJpbmQoKTtcbiAgICAgIGlmIChjb25maWcuU0hBRElORyAmJiBkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudGV4ZWxTaXplKSB7XG4gICAgICAgIGdsLnVuaWZvcm0yZihkaXNwbGF5TWF0ZXJpYWwudW5pZm9ybXMudGV4ZWxTaXplLCAxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc3BsYXlNYXRlcmlhbC51bmlmb3Jtcy51VGV4dHVyZSkge1xuICAgICAgICBnbC51bmlmb3JtMWkoZGlzcGxheU1hdGVyaWFsLnVuaWZvcm1zLnVUZXh0dXJlLCBkeWUucmVhZC5hdHRhY2goMCkpO1xuICAgICAgfVxuICAgICAgYmxpdCh0YXJnZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxhdFBvaW50ZXIocG9pbnRlcjogUG9pbnRlcikge1xuICAgICAgY29uc3QgZHggPSBwb2ludGVyLmRlbHRhWCAqIGNvbmZpZy5TUExBVF9GT1JDRTtcbiAgICAgIGNvbnN0IGR5ID0gcG9pbnRlci5kZWx0YVkgKiBjb25maWcuU1BMQVRfRk9SQ0U7XG4gICAgICBzcGxhdChwb2ludGVyLnRleGNvb3JkWCwgcG9pbnRlci50ZXhjb29yZFksIGR4LCBkeSwgcG9pbnRlci5jb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2tTcGxhdChwb2ludGVyOiBQb2ludGVyKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgIGNvbG9yLnIgKj0gMTA7XG4gICAgICBjb2xvci5nICo9IDEwO1xuICAgICAgY29sb3IuYiAqPSAxMDtcbiAgICAgIGNvbnN0IGR4ID0gMTAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgICBjb25zdCBkeSA9IDMwICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgc3BsYXQocG9pbnRlci50ZXhjb29yZFgsIHBvaW50ZXIudGV4Y29vcmRZLCBkeCwgZHksIGNvbG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxhdChcbiAgICAgIHg6IG51bWJlcixcbiAgICAgIHk6IG51bWJlcixcbiAgICAgIGR4OiBudW1iZXIsXG4gICAgICBkeTogbnVtYmVyLFxuICAgICAgY29sb3I6IENvbG9yUkdCXG4gICAgKSB7XG4gICAgICBzcGxhdFByb2dyYW0uYmluZCgpO1xuICAgICAgaWYgKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy51VGFyZ2V0KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgdmVsb2NpdHkucmVhZC5hdHRhY2goMCkpO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5hc3BlY3RSYXRpbykge1xuICAgICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgICAgc3BsYXRQcm9ncmFtLnVuaWZvcm1zLmFzcGVjdFJhdGlvLFxuICAgICAgICAgIGNhbnZhcyEud2lkdGggLyBjYW52YXMhLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5wb2ludCkge1xuICAgICAgICBnbC51bmlmb3JtMmYoc3BsYXRQcm9ncmFtLnVuaWZvcm1zLnBvaW50LCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IpIHtcbiAgICAgICAgZ2wudW5pZm9ybTNmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgZHgsIGR5LCAwKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMucmFkaXVzKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgICBzcGxhdFByb2dyYW0udW5pZm9ybXMucmFkaXVzLFxuICAgICAgICAgIGNvcnJlY3RSYWRpdXMoY29uZmlnLlNQTEFUX1JBRElVUyAvIDEwMCkhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBibGl0KHZlbG9jaXR5LndyaXRlKTtcbiAgICAgIHZlbG9jaXR5LnN3YXAoKTtcblxuICAgICAgaWYgKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy51VGFyZ2V0KSB7XG4gICAgICAgIGdsLnVuaWZvcm0xaShzcGxhdFByb2dyYW0udW5pZm9ybXMudVRhcmdldCwgZHllLnJlYWQuYXR0YWNoKDApKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGxhdFByb2dyYW0udW5pZm9ybXMuY29sb3IpIHtcbiAgICAgICAgZ2wudW5pZm9ybTNmKHNwbGF0UHJvZ3JhbS51bmlmb3Jtcy5jb2xvciwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICB9XG4gICAgICBibGl0KGR5ZS53cml0ZSk7XG4gICAgICBkeWUuc3dhcCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3RSYWRpdXMocmFkaXVzOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gY2FudmFzIS53aWR0aCAvIGNhbnZhcyEuaGVpZ2h0O1xuICAgICAgaWYgKGFzcGVjdFJhdGlvID4gMSkgcmFkaXVzICo9IGFzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyRG93bkRhdGEoXG4gICAgICBwb2ludGVyOiBQb2ludGVyLFxuICAgICAgaWQ6IG51bWJlcixcbiAgICAgIHBvc1g6IG51bWJlcixcbiAgICAgIHBvc1k6IG51bWJlclxuICAgICkge1xuICAgICAgcG9pbnRlci5pZCA9IGlkO1xuICAgICAgcG9pbnRlci5kb3duID0gdHJ1ZTtcbiAgICAgIHBvaW50ZXIubW92ZWQgPSBmYWxzZTtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRYID0gcG9zWCAvIGNhbnZhcyEud2lkdGg7XG4gICAgICBwb2ludGVyLnRleGNvb3JkWSA9IDEgLSBwb3NZIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgcG9pbnRlci5kZWx0YVggPSAwO1xuICAgICAgcG9pbnRlci5kZWx0YVkgPSAwO1xuICAgICAgcG9pbnRlci5jb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb2ludGVyTW92ZURhdGEoXG4gICAgICBwb2ludGVyOiBQb2ludGVyLFxuICAgICAgcG9zWDogbnVtYmVyLFxuICAgICAgcG9zWTogbnVtYmVyLFxuICAgICAgY29sb3I6IENvbG9yUkdCXG4gICAgKSB7XG4gICAgICBwb2ludGVyLnByZXZUZXhjb29yZFggPSBwb2ludGVyLnRleGNvb3JkWDtcbiAgICAgIHBvaW50ZXIucHJldlRleGNvb3JkWSA9IHBvaW50ZXIudGV4Y29vcmRZO1xuICAgICAgcG9pbnRlci50ZXhjb29yZFggPSBwb3NYIC8gY2FudmFzIS53aWR0aDtcbiAgICAgIHBvaW50ZXIudGV4Y29vcmRZID0gMSAtIHBvc1kgLyBjYW52YXMhLmhlaWdodDtcbiAgICAgIHBvaW50ZXIuZGVsdGFYID0gY29ycmVjdERlbHRhWChcbiAgICAgICAgcG9pbnRlci50ZXhjb29yZFggLSBwb2ludGVyLnByZXZUZXhjb29yZFhcbiAgICAgICkhO1xuICAgICAgcG9pbnRlci5kZWx0YVkgPSBjb3JyZWN0RGVsdGFZKFxuICAgICAgICBwb2ludGVyLnRleGNvb3JkWSAtIHBvaW50ZXIucHJldlRleGNvb3JkWVxuICAgICAgKSE7XG4gICAgICBwb2ludGVyLm1vdmVkID1cbiAgICAgICAgTWF0aC5hYnMocG9pbnRlci5kZWx0YVgpID4gMCB8fCBNYXRoLmFicyhwb2ludGVyLmRlbHRhWSkgPiAwO1xuICAgICAgcG9pbnRlci5jb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXJVcERhdGEocG9pbnRlcjogUG9pbnRlcikge1xuICAgICAgcG9pbnRlci5kb3duID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdERlbHRhWChkZWx0YTogbnVtYmVyKSB7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGNhbnZhcyEud2lkdGggLyBjYW52YXMhLmhlaWdodDtcbiAgICAgIGlmIChhc3BlY3RSYXRpbyA8IDEpIGRlbHRhICo9IGFzcGVjdFJhdGlvO1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWx0YVkoZGVsdGE6IG51bWJlcikge1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYW52YXMhLndpZHRoIC8gY2FudmFzIS5oZWlnaHQ7XG4gICAgICBpZiAoYXNwZWN0UmF0aW8gPiAxKSBkZWx0YSAvPSBhc3BlY3RSYXRpbztcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbG9yKCk6IENvbG9yUkdCIHtcbiAgICAgIGNvbnN0IGMgPSBIU1Z0b1JHQihNYXRoLnJhbmRvbSgpLCAxLjAsIDEuMCk7XG4gICAgICBjLnIgKj0gMC4xNTtcbiAgICAgIGMuZyAqPSAwLjE1O1xuICAgICAgYy5iICo9IDAuMTU7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBIU1Z0b1JHQihoOiBudW1iZXIsIHM6IG51bWJlciwgdjogbnVtYmVyKTogQ29sb3JSR0Ige1xuICAgICAgbGV0IHIgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgYiA9IDA7XG4gICAgICBjb25zdCBpID0gTWF0aC5mbG9vcihoICogNik7XG4gICAgICBjb25zdCBmID0gaCAqIDYgLSBpO1xuICAgICAgY29uc3QgcCA9IHYgKiAoMSAtIHMpO1xuICAgICAgY29uc3QgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgICAgIGNvbnN0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSB0O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IHE7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBxO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHIsIGcsIGIgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICAgICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICBpZiAocmFuZ2UgPT09IDApIHJldHVybiBtaW47XG4gICAgICByZXR1cm4gKCh2YWx1ZSAtIG1pbikgJSByYW5nZSkgKyBtaW47XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgICB1cGRhdGVQb2ludGVyRG93bkRhdGEocG9pbnRlciwgLTEsIHBvc1gsIHBvc1kpO1xuICAgICAgY2xpY2tTcGxhdChwb2ludGVyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUZpcnN0TW91c2VNb3ZlKGU6IE1vdXNlRXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFgpO1xuICAgICAgY29uc3QgcG9zWSA9IHNjYWxlQnlQaXhlbFJhdGlvKGUuY2xpZW50WSk7XG4gICAgICBjb25zdCBjb2xvciA9IGdlbmVyYXRlQ29sb3IoKTtcbiAgICAgIHVwZGF0ZUZyYW1lKCk7XG4gICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgY29sb3IpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZUZpcnN0TW91c2VNb3ZlKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZUZpcnN0TW91c2VNb3ZlKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8oZS5jbGllbnRYKTtcbiAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyhlLmNsaWVudFkpO1xuICAgICAgY29uc3QgY29sb3IgPSBwb2ludGVyLmNvbG9yO1xuICAgICAgdXBkYXRlUG9pbnRlck1vdmVEYXRhKHBvaW50ZXIsIHBvc1gsIHBvc1ksIGNvbG9yKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUZpcnN0VG91Y2hTdGFydChlOiBUb3VjaEV2ZW50KSB7XG4gICAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgICBjb25zdCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgdXBkYXRlRnJhbWUoKTtcbiAgICAgICAgdXBkYXRlUG9pbnRlckRvd25EYXRhKHBvaW50ZXIsIHRvdWNoZXNbaV0uaWRlbnRpZmllciwgcG9zWCwgcG9zWSk7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZUZpcnN0VG91Y2hTdGFydCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlRmlyc3RUb3VjaFN0YXJ0KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCB0b3VjaGVzID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBvc1ggPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFgpO1xuICAgICAgICAgIGNvbnN0IHBvc1kgPSBzY2FsZUJ5UGl4ZWxSYXRpbyh0b3VjaGVzW2ldLmNsaWVudFkpO1xuICAgICAgICAgIHVwZGF0ZVBvaW50ZXJEb3duRGF0YShwb2ludGVyLCB0b3VjaGVzW2ldLmlkZW50aWZpZXIsIHBvc1gsIHBvc1kpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgY29uc3QgdG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwb3NYID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRYKTtcbiAgICAgICAgICBjb25zdCBwb3NZID0gc2NhbGVCeVBpeGVsUmF0aW8odG91Y2hlc1tpXS5jbGllbnRZKTtcbiAgICAgICAgICB1cGRhdGVQb2ludGVyTW92ZURhdGEocG9pbnRlciwgcG9zWCwgcG9zWSwgcG9pbnRlci5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBwb2ludGVyc1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQb2ludGVyVXBEYXRhKHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXG4gICAgU0lNX1JFU09MVVRJT04sXG4gICAgRFlFX1JFU09MVVRJT04sXG4gICAgQ0FQVFVSRV9SRVNPTFVUSU9OLFxuICAgIERFTlNJVFlfRElTU0lQQVRJT04sXG4gICAgVkVMT0NJVFlfRElTU0lQQVRJT04sXG4gICAgUFJFU1NVUkUsXG4gICAgUFJFU1NVUkVfSVRFUkFUSU9OUyxcbiAgICBDVVJMLFxuICAgIFNQTEFUX1JBRElVUyxcbiAgICBTUExBVF9GT1JDRSxcbiAgICBTSEFESU5HLFxuICAgIENPTE9SX1VQREFURV9TUEVFRCxcbiAgICBCQUNLX0NPTE9SLFxuICAgIFRSQU5TUEFSRU5ULFxuICBdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHotNTAgcG9pbnRlci1ldmVudHMtbm9uZSB3LWZ1bGwgaC1mdWxsXCI+XG4gICAgICA8Y2FudmFzXG4gICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICBpZD1cImZsdWlkXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidy1zY3JlZW4gaC1zY3JlZW4gYmxvY2tcIlxuICAgICAgPjwvY2FudmFzPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwicG9pbnRlclByb3RvdHlwZSIsImlkIiwidGV4Y29vcmRYIiwidGV4Y29vcmRZIiwicHJldlRleGNvb3JkWCIsInByZXZUZXhjb29yZFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJkb3duIiwibW92ZWQiLCJjb2xvciIsInIiLCJnIiwiYiIsIlNwbGFzaEN1cnNvciIsIlNJTV9SRVNPTFVUSU9OIiwiRFlFX1JFU09MVVRJT04iLCJDQVBUVVJFX1JFU09MVVRJT04iLCJERU5TSVRZX0RJU1NJUEFUSU9OIiwiVkVMT0NJVFlfRElTU0lQQVRJT04iLCJQUkVTU1VSRSIsIlBSRVNTVVJFX0lURVJBVElPTlMiLCJDVVJMIiwiU1BMQVRfUkFESVVTIiwiU1BMQVRfRk9SQ0UiLCJTSEFESU5HIiwiQ09MT1JfVVBEQVRFX1NQRUVEIiwiQkFDS19DT0xPUiIsIlRSQU5TUEFSRU5UIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsInBvaW50ZXJzIiwiY29uZmlnIiwiUEFVU0VEIiwiZ2wiLCJleHQiLCJnZXRXZWJHTENvbnRleHQiLCJzdXBwb3J0TGluZWFyRmlsdGVyaW5nIiwicGFyYW1zIiwiYWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJnZXRDb250ZXh0IiwiRXJyb3IiLCJpc1dlYkdMMiIsImhhbGZGbG9hdCIsImdldEV4dGVuc2lvbiIsImNsZWFyQ29sb3IiLCJoYWxmRmxvYXRUZXhUeXBlIiwiSEFMRl9GTE9BVCIsIkhBTEZfRkxPQVRfT0VTIiwiZm9ybWF0UkdCQSIsImZvcm1hdFJHIiwiZm9ybWF0UiIsImdldFN1cHBvcnRlZEZvcm1hdCIsIlJHQkExNkYiLCJSR0JBIiwiUkcxNkYiLCJSRyIsIlIxNkYiLCJSRUQiLCJpbnRlcm5hbEZvcm1hdCIsImZvcm1hdCIsInR5cGUiLCJzdXBwb3J0UmVuZGVyVGV4dHVyZUZvcm1hdCIsImdsMiIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIk5FQVJFU1QiLCJURVhUVVJFX01BR19GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsInRleEltYWdlMkQiLCJmYm8iLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInN0YXR1cyIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsImhhc2hDb2RlIiwicyIsImxlbmd0aCIsImhhc2giLCJpIiwiY2hhckNvZGVBdCIsImFkZEtleXdvcmRzIiwic291cmNlIiwia2V5d29yZHMiLCJrZXl3b3Jkc1N0cmluZyIsImtleXdvcmQiLCJjb21waWxlU2hhZGVyIiwic2hhZGVyU291cmNlIiwic2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJjb25zb2xlIiwidHJhY2UiLCJnZXRTaGFkZXJJbmZvTG9nIiwiY3JlYXRlUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJnZXRVbmlmb3JtcyIsInVuaWZvcm1zIiwidW5pZm9ybUNvdW50IiwiQUNUSVZFX1VOSUZPUk1TIiwidW5pZm9ybUluZm8iLCJnZXRBY3RpdmVVbmlmb3JtIiwibmFtZSIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIlByb2dyYW0iLCJiaW5kIiwidXNlUHJvZ3JhbSIsImNvbnN0cnVjdG9yIiwiTWF0ZXJpYWwiLCJzZXRLZXl3b3JkcyIsImt3IiwicHJvZ3JhbXMiLCJGUkFHTUVOVF9TSEFERVIiLCJmcmFnbWVudFNoYWRlclNvdXJjZSIsImFjdGl2ZVByb2dyYW0iLCJiYXNlVmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImNvcHlTaGFkZXIiLCJjbGVhclNoYWRlciIsImRpc3BsYXlTaGFkZXJTb3VyY2UiLCJzcGxhdFNoYWRlciIsImFkdmVjdGlvblNoYWRlciIsImRpdmVyZ2VuY2VTaGFkZXIiLCJjdXJsU2hhZGVyIiwidm9ydGljaXR5U2hhZGVyIiwicHJlc3N1cmVTaGFkZXIiLCJncmFkaWVudFN1YnRyYWN0U2hhZGVyIiwiYmxpdCIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJlbGVtQnVmZmVyIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJVaW50MTZBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidGFyZ2V0IiwiZG9DbGVhciIsInZpZXdwb3J0IiwiZHJhd2luZ0J1ZmZlcldpZHRoIiwiZHJhd2luZ0J1ZmZlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJkeWUiLCJ2ZWxvY2l0eSIsImRpdmVyZ2VuY2UiLCJjdXJsIiwicHJlc3N1cmUiLCJjb3B5UHJvZ3JhbSIsImNsZWFyUHJvZ3JhbSIsInNwbGF0UHJvZ3JhbSIsImFkdmVjdGlvblByb2dyYW0iLCJkaXZlcmdlbmNlUHJvZ3JhbSIsImN1cmxQcm9ncmFtIiwidm9ydGljaXR5UHJvZ3JhbSIsInByZXNzdXJlUHJvZ3JhbSIsImdyYWRpZW5TdWJ0cmFjdFByb2dyYW0iLCJkaXNwbGF5TWF0ZXJpYWwiLCJjcmVhdGVGQk8iLCJ3IiwiaCIsInBhcmFtIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwidGV4ZWxTaXplWCIsInRleGVsU2l6ZVkiLCJhdHRhY2giLCJjcmVhdGVEb3VibGVGQk8iLCJmYm8xIiwiZmJvMiIsInJlYWQiLCJ3cml0ZSIsInN3YXAiLCJ0bXAiLCJyZXNpemVGQk8iLCJuZXdGQk8iLCJ1VGV4dHVyZSIsInVuaWZvcm0xaSIsInJlc2l6ZURvdWJsZUZCTyIsImluaXRGcmFtZWJ1ZmZlcnMiLCJzaW1SZXMiLCJnZXRSZXNvbHV0aW9uIiwiZHllUmVzIiwidGV4VHlwZSIsInJnYmEiLCJyZyIsImZpbHRlcmluZyIsIkxJTkVBUiIsImRpc2FibGUiLCJCTEVORCIsInVwZGF0ZUtleXdvcmRzIiwiZGlzcGxheUtleXdvcmRzIiwicHVzaCIsInJlc29sdXRpb24iLCJhc3BlY3RSYXRpbyIsImFzcGVjdCIsIm1pbiIsIk1hdGgiLCJyb3VuZCIsIm1heCIsInNjYWxlQnlQaXhlbFJhdGlvIiwiaW5wdXQiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImZsb29yIiwibGFzdFVwZGF0ZVRpbWUiLCJEYXRlIiwibm93IiwiY29sb3JVcGRhdGVUaW1lciIsInVwZGF0ZUZyYW1lIiwiZHQiLCJjYWxjRGVsdGFUaW1lIiwicmVzaXplQ2FudmFzIiwidXBkYXRlQ29sb3JzIiwiYXBwbHlJbnB1dHMiLCJzdGVwIiwicmVuZGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJ3cmFwIiwiZm9yRWFjaCIsInAiLCJnZW5lcmF0ZUNvbG9yIiwic3BsYXRQb2ludGVyIiwidGV4ZWxTaXplIiwidW5pZm9ybTJmIiwidVZlbG9jaXR5IiwidUN1cmwiLCJ1bmlmb3JtMWYiLCJ2YWx1ZSIsInVEaXZlcmdlbmNlIiwidVByZXNzdXJlIiwiZHllVGV4ZWxTaXplIiwidmVsb2NpdHlJZCIsInVTb3VyY2UiLCJkaXNzaXBhdGlvbiIsImJsZW5kRnVuYyIsIk9ORSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJlbmFibGUiLCJkcmF3RGlzcGxheSIsInBvaW50ZXIiLCJkeCIsImR5Iiwic3BsYXQiLCJjbGlja1NwbGF0IiwicmFuZG9tIiwieCIsInkiLCJ1VGFyZ2V0IiwicG9pbnQiLCJ1bmlmb3JtM2YiLCJyYWRpdXMiLCJjb3JyZWN0UmFkaXVzIiwidXBkYXRlUG9pbnRlckRvd25EYXRhIiwicG9zWCIsInBvc1kiLCJ1cGRhdGVQb2ludGVyTW92ZURhdGEiLCJjb3JyZWN0RGVsdGFYIiwiY29ycmVjdERlbHRhWSIsImFicyIsInVwZGF0ZVBvaW50ZXJVcERhdGEiLCJkZWx0YSIsImMiLCJIU1Z0b1JHQiIsInYiLCJmIiwicSIsInQiLCJyYW5nZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2xpZW50WCIsImNsaWVudFkiLCJoYW5kbGVGaXJzdE1vdXNlTW92ZSIsImRvY3VtZW50IiwiYm9keSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVGaXJzdFRvdWNoU3RhcnQiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImlkZW50aWZpZXIiLCJjaGFuZ2VkVG91Y2hlcyIsImRpdiIsImNsYXNzTmFtZSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/SplashCursor.tsx\n"));

/***/ }),

/***/ "./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Hero__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Hero */ \"./components/Hero.tsx\");\n/* harmony import */ var _components_About__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/About */ \"./components/About.tsx\");\n/* harmony import */ var _components_Projects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Projects */ \"./components/Projects.tsx\");\n/* harmony import */ var _components_Resume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Resume */ \"./components/Resume.tsx\");\n/* harmony import */ var _components_SplashCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/SplashCursor */ \"./components/SplashCursor.tsx\");\n\n\n\n\n\n\n/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SplashCursor__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n    fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n    lineNumber: 7,\n    columnNumber: 1\n}, undefined);\nfunction HomePage() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"bg-black text-white scroll-smooth\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Hero__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_About__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Projects__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n                lineNumber: 14,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Resume__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SplashCursor__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/elliott/Downloads/zihao-anime-site/pages/index.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0U7QUFDTTtBQUNKO0FBQ1k7Y0FFdEQsOERBQUNJLGdFQUFZQTs7Ozs7QUFFRSxTQUFTQztJQUN0QixxQkFDRSw4REFBQ0M7UUFBS0MsV0FBVTs7MEJBQ2QsOERBQUNQLHdEQUFJQTs7Ozs7MEJBQ0wsOERBQUNDLHlEQUFLQTs7Ozs7MEJBQ04sOERBQUNDLDREQUFRQTs7Ozs7MEJBQ1QsOERBQUNDLDBEQUFNQTs7Ozs7MEJBQ1AsOERBQUNDLGdFQUFZQTs7Ozs7Ozs7Ozs7QUFHbkI7S0FWd0JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LnRzeD8wN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZXJvIGZyb20gXCIuLi9jb21wb25lbnRzL0hlcm9cIjtcbmltcG9ydCBBYm91dCBmcm9tIFwiLi4vY29tcG9uZW50cy9BYm91dFwiO1xuaW1wb3J0IFByb2plY3RzIGZyb20gXCIuLi9jb21wb25lbnRzL1Byb2plY3RzXCI7XG5pbXBvcnQgUmVzdW1lIGZyb20gXCIuLi9jb21wb25lbnRzL1Jlc3VtZVwiO1xuaW1wb3J0IFNwbGFzaEN1cnNvciBmcm9tIFwiLi4vY29tcG9uZW50cy9TcGxhc2hDdXJzb3JcIjtcblxuPFNwbGFzaEN1cnNvciAvPjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZVBhZ2UoKSB7XG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwiYmctYmxhY2sgdGV4dC13aGl0ZSBzY3JvbGwtc21vb3RoXCI+XG4gICAgICA8SGVybyAvPlxuICAgICAgPEFib3V0IC8+XG4gICAgICA8UHJvamVjdHMgLz5cbiAgICAgIDxSZXN1bWUgLz5cbiAgICAgIDxTcGxhc2hDdXJzb3IgLz5cbiAgICA8L21haW4+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiSGVybyIsIkFib3V0IiwiUHJvamVjdHMiLCJSZXN1bWUiLCJTcGxhc2hDdXJzb3IiLCJIb21lUGFnZSIsIm1haW4iLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.tsx\n"));

/***/ })

});